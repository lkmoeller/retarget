#######################################################################################################################
#
# Predict and filter editing outcomes using Lindel. Bring results to the same format than inDelphi predictions
# Original version of the script (using Lindel to generate predictions) authored by Will Chen (Chen, W. et al. Nucleic
# Acids Res. 47, 7989â€“8003 (2019))
#
# Author: Lukas Moeller - 11/2021
#
#######################################################################################################################



import os
import pickle as pkl
import pandas as pd
from recursive_editing import config
import Lindel
from Lindel.Predictor import *


weights = pkl.load(open(os.path.join(Lindel.__path__[0], "Model_weights.pkl"),'rb'))
prerequesites = pkl.load(open(os.path.join(Lindel.__path__[0],'model_prereq.pkl'),'rb'))


def generate_tmp_tf(seq, array, freq, full_seq):
    """
    generate same output data frame than generated by inDelphi
    """
    sequences, frequency, indels, ins_base, ind_length, ind_pos = [], [], [], [], [], []
    s_num = 13
    for i in range(len(array)):
        pt = array[i][0]

        # process deletions
        try:
            idx1, dl = map(int, pt.split('+'))
            idx1 += (s_num + 17)
            idx2 = idx1 + dl
            s = seq[0:idx1] + seq[idx2:]
            indels.append('del')
            ins_base.append(float('nan'))
            ind_length.append(int(dl))
            ind_pos.append(int(idx2-30))
        
        # process insertions
        except ValueError:
            idx1 = int(pt.split('+')[0])
            if pt != '3':
                bp = pt.split('+')[1]
                il = str(idx1)
                indels.append('ins')
                ins_base.append(bp)
                ind_length.append(int(idx1))
                ind_pos.append(float('nan'))
            else:
                bp = 'X'
                indels.append('ins')
                ins_base.append(bp)
                ind_length.append(int(3))
                ind_pos.append(float('nan'))
            s = seq[0:s_num+17] + bp + seq[s_num+17:]
        
        left_index = full_seq.find(s[:15])
        right_index = full_seq.find(s[-15:])
        if left_index > 0:
            s = full_seq[:left_index] + s
        if right_index > 0:
            s = s + full_seq[right_index+15:]
        sequences.append(''.join(s))
        frequency.append(freq[pt]*100)
    
    tmp_df = pd.DataFrame(list(zip(indels, ind_pos, ins_base, ind_length, frequency, sequences)),
                columns=['Category', 'Genotype position', 'Inserted Bases', 'Length', 'Predicted frequency', 'Genotype'])
    
    return tmp_df


def run_lindel(full_seq, cutsite):
    """
    use Lindel to generate predictions for editing outcomes
    """
    try:
        # generate predictions
        seq = full_seq[cutsite-30:cutsite+30]
        y_hat, _ = gen_prediction(seq, weights, prerequesites)
        rev_index = prerequesites[1]
        pred_freq = {}
        for i in range(len(y_hat)):
            if y_hat[i]!=0:
                pred_freq[rev_index[i]] = y_hat[i]
        pred_sorted = sorted(pred_freq.items(), key=lambda kv: kv[1],reverse=True)
        tmp_df = generate_tmp_tf(seq, pred_sorted, pred_freq, full_seq)
        # filter predictions
        tmp_df = tmp_df[tmp_df.Genotype.notna()]
        tmp_df = tmp_df[tmp_df['Inserted Bases'] != 'X']
        tmp_df = tmp_df.sort_values(by='Predicted frequency', ascending=False)
        tmp_df = tmp_df.head(config.MAX_GUIDES)
        tmp_df = tmp_df[tmp_df['Predicted frequency'] > config.SINGLE_FREQ_CUT]
        return tmp_df
    except ValueError:
        return pd.DataFrame()
